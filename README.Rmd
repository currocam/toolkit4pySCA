---
output: github_document
always_allow_html: true
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# toolkit4pySCA

<!-- badges: start -->
[![R-CMD-check](https://github.com/currocam/toolkit4pySCA/workflows/R-CMD-check/badge.svg)](https://github.com/currocam/toolkit4pySCA/actions)
<!-- badges: end -->

The goal of toolkit4pySCA is to provide a bunch of useful functions in order to obtain a sequence alignment using HMMER and associated taxonomic information.Then, it allows to read the file generated by pySCA and to analyze the results easily with R and tidyverse.

## Installation

You can install the development version of toolkit4pySCA from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("currocam/toolkit4pySCA")
```

## Example

This is a basic example showing how to carry out a typical workflow. 

### phmmer

First, we performed a search for sequences homologous to the sequence of interest using phmmer, indicating the sequence of interest and the database. This can be done using `quick_AA_search_using_phmmer`, `download_xml_from_phmer()` or downloading the xml file from the web server. Actually, programmatic access to the HMMER only seems to make sense if you need to perform a lot of queries and want to automate the process. 

``` r 
library(toolkit4pySCA)
progressr::handlers(global = TRUE)

db <- c("swissprot", "pdb")
# >2abl_A mol:protein length:163  ABL TYROSINE KINASE
example.seq <- AAString(
  paste0("MGPSENDPNLFVALYDFVASGDNTLSITKGEKLRVLGYNHNGEWCEAQTKNGQGWVPSNYITPVNSLE",
         "KHSWYHGPVSRNAAEYLLSSGINGSFLVRESESSPGQRSISLRYEGRVYHYRINTASDGKLYVSSESRFNTLAELV",
         "HHHSTVADGLITTLHYPAP")
df.phmmer <- quick_AA_search_using_phmmer(example.seq, db)
```

```{r read_xml, include=FALSE}
library(toolkit4pySCA)

path <- system.file("extdata/",package = "toolkit4pySCA")
xml.files <- purrr::map_chr(dir(path, pattern = "*.xml"), ~paste0(path, .x))
fullseq.fasta.files <- purrr::map_chr(dir(path, pattern = "*fullseq.fa"), ~paste0(path, .x))
```
``` r
library(Biostrings)
library(xml2)
fasta.files <- readAAStringSet(fullseq.fasta.files)
df.phmmer.info <- xml.files %>%
  purrr::map_dfr(
    ~read_xml(.x) %>%
      extract_tidy_df_from_hmmer,
    .id = "db")
```

```{r, include=FALSE}
library(Biostrings)
library(xml2)
fasta.files <- readAAStringSet(fullseq.fasta.files)
df.phmmer.info <- xml.files %>%
  purrr::map_dfr(
    ~read_xml(.x) %>%
      extract_tidy_df_from_hmmer,
    .id = "db")
```


``` r
library(dplyr)
hits <- extract_tidy_hits_from_xml(xml.document)
stats <- extract_tidy_stats_from_xml(xml.document)
hits%>%
  select(pvalue, evalue, score) %>%
  summary()
```
```
library(dplyr)
hits <- df.phmmer.info%>%
  group_by(alisqacc) 
hits %>%
  select(alisqacc, pvalue, evalue, score) %>%
  summary()
```
```{r summary, echo=FALSE, warning=FALSE, message=FALSE}
library(kableExtra)
library(dplyr)
hits <- df.phmmer.info%>%
  group_by(alisqacc) 
hits %>%
  select(alisqacc, pvalue, evalue, score) %>%
  summary() %>%
  kbl() %>%
  kable_styling(position = "center")
```

```{r ph, warning=FALSE, message=FALSE}
library(forcats)
hits %>%
  mutate(
    ph = fct_lump(ph, 2),
  ) %>%
  pull(ph)%>%
  fct_count(prop = TRUE, sort = TRUE) %>%
  kbl() %>%
  kable_styling(position = "center")
```

```{r hist_ph_desc_hmmer, warning=FALSE, message=FALSE,dpi=500}
library(ggplot2)
library(tidyr)
library(dplyr)

df.phmmer.info%>%
  filter(evalue < 0.001) %>%
  mutate(
  desc = fct_lump_n(desc, 5),
  ph = fct_lump(ph, 2),
  )%>%
  group_by(ph, desc) %>%
  nest() %>%
  ggplot(aes(y=desc, fill = ph)) + 
    geom_histogram(stat = "count")
```

```{r}
tax.df <- hits %>%
    pull(taxid) %>%
    download_tax_from_ncbi() %>%
    mutate(taxid = as.numeric(taxid))

hits %>%
  left_join(tax.df, by = c("taxid" = "taxid"))
```


You'll still need to render `README.Rmd` regularly, to keep `README.md` up-to-date. `devtools::build_readme()` is handy for this. You could also use GitHub Actions to re-render `README.Rmd` every time you push. An example workflow can be found here: <https://github.com/r-lib/actions/tree/v1/examples>.

